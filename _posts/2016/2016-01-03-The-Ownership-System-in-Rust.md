---
title: Rust中的所有权系统
tags : [编程,日志]
---
Rust语言有两个主要的目标，第一：安全；第二：效率。为了达到第一个目标，Rust中引入了所有权系统，所有权系统包含三个部分，分别是“所有权”，“引用与借用”以及“寿命”。

# 所有权（Ownership)#
在Rust语言中，一个变量绑定到一个值，那么我们就说这个变量拥有这个值的所有权，换句话说，这个变量拥有这个值。拥有这个值什么意思呢？就是说这个值，被这个变量所管理。
例如在下面的代码中，30是一个值，这个值的存在`test()`函数的栈内存中。这个值的所有权归变量x所有，这就意味着，我们可以通过x变量来访问这个内存的值。如果我们声明变量的时候，把这个变量声明为可以改变的，如下面的代码中对y的声明那样，我们就不仅能读取变量中的值，而且还可以通过变量来修改这个值得内容。

```Rust
fn test(){
    let x = 30;
    let mut y = 30;
    y = y + 1;
    println!("x:{},y:{}",x,y);
}
```
所以，对于在Rust中的所有权，可以理解为，可以通过那个变量来访问或操作值。对于基本的变量，我们通过上面的例子已经看到了，下面我们看看对于在堆中分配的变量，所有权又意味着什么。

```Rust
fn main()
{
    let x= vec![1,2,3];
    let x2= x;
    println!("x[0]:{}",x[0]);
}
```
编译这段代码，编译器报错，告诉我的如下的错误：`error: use of moved value: 'x' `.什么意思呢？

注意上面的代码的第4行，这一行我们变量x赋值给了变量x2。因为x的值，不是一个原始类型，而是一个矢量（vec），这个矢量的值是在`main`函数的栈内存中，它的值是一个堆内存的地址。在堆内存中，最后的存放了矢量的数据内容。现在通过第4行代码，是把x的值（那个指向堆内存的地址）赋给了变量x2。因此，x2中记录的也是指向堆内存的地址。这样，对于同样的一个物理资源（堆内存地址对应的内存空间）有两个变量同时拥有。这就是竞争出现的地方。为了避免竞争的出现，Rust规定，一个内容，在一个时间点只能通过一个变量使用。如果想上面的代码那样，把变量x的值赋给变量y，那么就相当于x对原来值得所有权被移除（moved）了。

那么为什么上面的第一个代码中，对原始类型的赋值没有被移除呢？在Rust语言自己的教程中的解释是说，原始类型，实现了Copy特性，因此赋值的时候是进行了复制的操作，而不是做所有权的转移。

其实这里的问题，就是C/C++中的所谓的深拷贝浅拷贝的问题。对于原始类型的变量，只存在深拷贝，对于指针类型的变量，却有对指针的值的拷贝，还是对指针指向的内容的值的拷贝的问题。在Rust中，如果一个类型没有实现Copy特性，那么就进行简单的指针的值复制，相当于C/C++的浅拷贝。而如果实现了Copy特性，那么就进行深拷贝的操作，对指针的值指向的内容进行拷贝。浅拷贝在Rust中还伴随着所有权的转移问题。这是和C/C++中不一样的地方。一个值的所有权发生转移之后，这个值的寿命就由获得其所有权的变量的作用范围来管理了。

所以，设想一下，如果我们把上面的第二个例子的中y变量的作用范围缩小，在y的作用范围后面，x会拥有它原来的值吗？答案是否定的。

```Rust
fn main()
{
    let x = vec![1,2,3];
    {
        let y = x;
    }
    println!("x[0]:{}",x[0]);
}
```
上面的这段代码已经不能通过编译，因为在第5行之后，y有了x原来值的所有权，当y离开它的作用范围的时候，它需要对它的值负责，需要清理它的值所指向的堆内存。所以，在第7行的时候，堆内存的值，已经被清空了，这个时候如果继续的让x可以访问它的值指向的堆内存，就是在使用悬空指针。这是C/C++代码中最难排错的BUG的来源之一。

现在我们再次改动我们的代码，当我们在y的作用区间内，再次的把y的值赋值给x，也就是说，我们让y的值的所有权归x，那么我们在y的作用区间外面能使用x获得他对应的值吗？答案是可行的。但是我们需要把x的声明修改一下，修改为`mut`()可变的)。

```Rust
fn main()
{
    let mut x = vec![1,2,3];
    {
        let y = x;
        println!("y[0]:{}",y[0]);
        x = y;
    }
    println!("x[0]:{}",x[0]);
}
```

现在我们明白了，在Rust中，对于没有实现Copy特性的类型，赋值会发生值的所有权的转移（从赋值号右边的变量转移给左边的变量）。除了赋值，把变量传递给函数的参数也是隐式的赋值，这也会发生变量的值的“所有权”的转移。

# 引用与借贷(References and Borrowing)#

变量对值的所有权的机制虽然解决了竞争的问题。但是对编程有引入了其他的困难，对函数参数的赋值会发生变量所有权的转移，如果没有其他的机制来简化的话，如果我们希望函数调用结束之后，调用函数还拥有变量值的所有权，就必须使用下面的编程技巧，及在调用函数中，把所有的传入参数，作为返回值，返回。

```Rust
fn callee(a:Vec<i32>,b:Vec<i32>) ->(Vec<i32>,Vec<i32>,i32)
{
    (a,b,35)
}
fn main()
{
    let a=vec![1,2,3];
    let b=vec![4,5];
    let (a,b,c)=callee(a,b);
}
```
上面的代码啰嗦，拖沓，一点都不简洁。
为了解决这个问题，Rust的所有权系统引入了第二个机制，“引用与借贷”。
这个机制和C++的引用类型（也有人说别名）十分的相似，或者我们就可以理解为是C++中引用机制的对应物。

以下是上面例子的引用版本：

```Rust
fn callee(a: &Vec<i32>,b:&Vec<i32>) -> (i32){
    (32);
}
fn main(){
    let a=vec![1,2,3];
    let b=vec![4,5,6];
    let c = callee(&a,&b);
}
```
现在我们要求的参数不是一个Vec，而是一个引用&Vec的。而传给`callee()`函数的不是a,b,而是`&a`,`&b`。在Rust中把`&T`叫做引用，它不拥有一个值的所有权，它借来一个值的所有权。一个绑定借来的所有权的时候，当它离开作用域的时候，不负责对这个资源进行回收。这就意味着，当`callee()`调用结束之后，`main()`函数中的`a`,`b`继续拥有它们的值的所有权。

引用和变量绑定一样，默认都是不可变得，如果需要改动引用的值，那就需要定义可变引用`&mut T`。

```Rust
fn main (){
    let mut a = 1;
    {
        let b = &mut a;
        *b += 1;
    }
    println!("a:%d",a);
}
```
可以看出，Rust中的语法和Object-C的语法是非常的接近的。对引用值得使用，和C语言中对指正的使用几乎是一样。

需要注意的上面的代码，因为`b`只是借用了a对值的所有权，`a`本身还保有值的所有权，所以如果这两个变量在一个作用域中（去掉上面代码中第3行和第6行的大括号），就有两个绑定都可以修改值的内容，这其实就引入了竞争。Rust保证程序的安全，所以不允许这种情况的出现。编译的时候就会给出错误。

因此结论就是：

+ 一个变量可以有多个不变的引用，
+ 但是最多只能有一个可变的引用。

# 寿命(Lifetime)#

考虑下面的代码：

```Rust
fn main(){
    let y:&i32;
    let x = 3;
    y=&x;
    println!("y:{}",y);
}
```
这段代码编译的时候会错误，提示的内容是说x的寿命不够长。
啥意思呢？
上面的代码中，y是先创建的，然后x才创建。在函数结束之后，通过退栈操作来释放内存，因此，x值是先于y值被释放的。当x被释放之后，值的内存就不存在了，但是这个时候，y还引用这这个内存地址，引用一个不存在的内存地址，这就是也就是所谓的悬挂指针问题。这在Rust中是不允许的。因此引用的寿命，应该比原始绑定的寿命短才行。

一个引用的寿命，描述的是一个引用的作用域和哪一个绑定的作用域一样。

当一个函数有一个引用参数的时候，它的引用参数的寿命有隐式的和显示的两种写法:

+ 隐式的写法为

    ```Rust
    fn foo(x:i32){

    }
    ```
+ 显式的写法为：

    ```Rust
    fn foo<'a>(x:&'a i32){

    }
    ```

`'a`读作a的寿命。`foo<'a>(x:&'a i32)`的意思是说参数x是一个i32的类型值的引用，这个x变量的寿命和a寿命一样。函数后面的尖括号，是函数的通用变量，寿命是通用变量用法的一种。

`'static`这是一个特殊的寿命，也就是说是静态寿命。当需要一个全局对象的引用的时候，就需要使用这个寿命了。

## 寿命声明的省略##
一个函数的参数的寿命称为输入寿命，返回值的寿命称为输出寿命。
省略的寿命声明通过下面三个规则制定：

1. 函数参数中的缺省的寿命，是参数的寿命。
2. 如果有一个输入寿命，无论缺省还是显式定义的，这个寿命就是所有的返回值的缺省的生命。
3. 如果有多个输入寿命，但是其中有一个是`&self`或`&mut slef`,那么所有的输出的缺省寿命都将是`self`的寿命。

其他情况省略输出寿命就是错误的。

寿命用来指定，参数或返回值的寿命和谁一样的长。这样来避免悬挂资源的产生。

# 总结#

Rust的中的所有权系统，很好的解决了资源什么时候释放，什么时候回收的问题，也统一的解决了，资源由谁创建，由谁回收的问题。而且是在语言层面解决的，不像C/C++，需要程序员之间，协商解决。

如果你看C/C++(我没有写过Object-C的代码，但是我想也要改也会有这样的问题)代码，你会发现，有不少人的代码中会对参数注明是输入参数还是输出参数，当然了，当参数的类型是指针或引用的时候才会有这样的注释必要。所谓输入参数，就是说，在这函数需要这个参数的输入值，但是一般不会对这个参数值做修改；所谓的输出参数，就是说，一般这个参数的原始值是什么，这个函数可能不关心，但是最后这个函数会把计算的结果，放到这个参数中，以便调用函数可以使用这个值。

在C语言中，常常能看到新手把一个栈变量的值，取地址后作为返回值返回。这样调用函数得到的就一定要是一个悬挂指针。如果这样的代码部署到生产环境，那最后一定是灾难。

在Rust中，通过语法问题，而不是通过注释，其实就是强制大家遵守协议，同时寿命的问题，在编译的时候，就能检查出来，也避免了把一个栈对象的引用返回，从而产生悬挂指针的问题。
