---
layout: default
title : R 語言學習(2)
tags  : [编程,读书]
---

# 對象:模型和屬性#
## 內部屬性: 風格和長度##

***原子*** 結構的對象,有類型一樣的元素組成.元素的類型叫做這個結構的風格(mode).一個原子類型的風格是一下中的一個: *numeric(數字),complex(複數),logiical(邏輯),character(字符)和 raw(原始類型).* NA是特殊值,可以認為是任意的類型.

__向量中的*元素*必須都是*同樣的風格*.__

__*lists*對象的風格是list__,它是一個有序的對象集合,其中的每個元素的可以是任意的風格.

通過一個對象的*mode*,我們知道這個對象的組成成分的基本的類型.這是一個對象的特殊的"屬性",每個對象都會有.另外的一個幾乎每個對象都有的屬性是*length*.函數對象沒有length屬性.
一個對象的其他的屬性可以通過*attributes(object)*來獲得.但是mode和length不行,因此mode和length被稱謂內部屬性.


不對的對象可以通過as.*()的函數來實現轉化:
1. as.character(x) 把x中的元素轉化為字符串
2. as.integer(x) 把x轉化為整數

## 改變一個對象的長度##
一個空的對象也是有風格的,例如如下代碼:

```R
e <- numeric()
e[3] <- 3
print(e) # NA,NA,3
```
第一行,創建一個空的數值向量.類似的character()創建一個空的字符串向量.一個已經創建的向量,向超過其長度的元素賦值,會增加向量的長度,例如上面代碼的第2行那樣.

可以通過賦值的方法,來改變一個對象的長度,例如:

```R
e=1:10;
e<- e[1:5];
```
還可以通過直接設置一個向量的長度,來改變他的程度,例如:

```R
a<- 1:100
length(a) <- 3
print(a) # 1 2 3
b <- 1:3;
length(b) <- 4
print(b); # 1 2 3 NA
```

## 獲取設置對象的屬性##

通過attributes(object)返回所有的非內部屬性的列表.函數attr(obj,name) 用來選擇一個特別的屬性.如果attr(obj,name)用在賦值的左邊,就是對obj設置一個名字name的屬性.例如:

```R
f <- 2
attr(f,"name") <- "tow"
attributes(f) # name \n "tow"
```

# 數組和矩陣#
## <a name="#array">數組</a>##
數組(array)是有多個下標的數據項的集合.矩陣是數組的特殊形式(有兩個下標).

當向量有一個dim的屬性數字向量的時候,R把這個向量當作一個數組.例如,下面的代碼構造了一個\\(3 \times 5 \times 100\\)的數組:

````R
z <- 1:1500
dim(z) <- c(3,5,100)
```
其中z中是按照列優先的順序來存儲數據的,也就是是z[1,1,1] <- 1,z[2,1,1]=2,z[3,1,1]=3,...
數組還可以是一維的,這樣數組被當作向量來處理(包括打印的時候)但是這樣做容易引起困惑.
## 數組的索引##
可以通過在一個數組名後面的方括號中給定有逗號分隔的下標來應用單個的數組元素.

更一般的情況是,可以通過用一個*索引向量*做下標來,*任何下標位置被給定一個空的索引向量的話,這個下標的範圍的全部元素都將被獲取.*
繼續[數組](#array)中的例子,z[2,,]是一個\\(5 \times 100 \\)的數組,a[,,]代表了整個的數組,和直接使用a效果一樣.

如果一個數組名後面只*有一個下標或索數組*,數據向量中對應的值將會被使用.例如:

```R
a <- 1:150;
dim(a) <- c(3,5,10);
a[1:10] ;1,2,3,4,5,6,7,8,9,10
a[2]; 2
```

但如果唯一的索引不是一個向量而是一個數組的話,情況就不一樣了.

```R
x <- array(1:20,dim=c(4,5))
i <- array(c(1:3,3:1),dim=c(3,2));
print(i)
#     [,1] [,2]
#[1,]    1    3
#[2,]    2    2
#[3,]    3    1
print(x[i])
#[1] 9 6 3
```

## 數組轉化##
函數aperm(array,perm)用來完成對一個數組的轉置處理,其中perm是一個{1,2,...,k}排列,這裡k是數組array的維度.新的數組的大小和array一樣,但是緯度排列不一樣,例如:

```R
a=array(1:150,dim=c(3,5,10)); # a is a array of 3 by 5 by 10
b= aperm(a,c(3,1,2);# same as a[i,j,k]=b[k,i,j]
i= 3;#i in [1,3]
j=4;#j  in [1,5]
k=6;#k in [1,10]
print(a[i,j,k) == b[k,i,j]) #TRUE
```
矩陣是二維的數組,矩陣的轉置除了使用aperm()函數外,還可以使用專門為矩陣編寫的函數t()完成同樣的工作.例如:

```R
a=array(1:10,dim=c(2,5))
b=aperm(a,c(2,1))
c=t(a)
b == c ;#  array(TRUE,dim=c(5,2)
```

## 矩陣乘法##
+ 操作符 %*%

    %*% 用來完成矩陣乘法:

    $$
C\_{i \times k}=A\_{i \times j} * B\_{j \times k}
$$

    $$
c\_{ik}=\sum\_{k=0}^{L}a_\{i j} * b\_{jk}
$$
    其中L為A的行數或B的列數.

+ 操作符*,用在緯度向量相同的矩陣直接,對應的元素相乘放在結果矩陣的對應的位置上.

+ 函數crossprod()完成叉乘操作.
croessprod(x,y),完成t(x) %*% y的共功能,只是效率更高.如果第二個參數被忽略,完成的是第一個矩陣自己和自己的叉乘.

+ diag()
    1. diag(v)
v是一個向量,生成一個對角元素為v的方陣.
    2. diag(m)
m是矩陣的話,給出m主對角線上的元素,作為一個數組返回.這個和MATLAB中的diag()函數一樣.
    3. diag(k)
如果k是一個數字,那麼diag(k)給出一個\\(k \times k\\)的單位矩陣.

## 線性方程和逆矩陣##

+ slove()函數
對矩陣運算b=A&times;x,如果知道了A和b的值,而求x
的結果,數學上就是x= A<sup>-1</sup>b.在R中使用solve(A,b)來計算x,也就是說solve(A,b)=A<sup>-1</sup>b,雖然solve(A)=A<sup>-1</sup>,但是solve(A)的計算不穩定,所以,在計算的時候,x=A<sup>-1</sup>b的時候,不要單獨計算A<sup>-1</sup>然後在計算A<sup>-1</sup>b.
