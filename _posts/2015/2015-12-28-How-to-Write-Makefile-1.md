---
title: 如何写Makefile文件(一)
tags: [编程,日志 ]
---

如何写Makefile，可以写整整的一本书，最初的时候，我也是从[《GNU Make中文手册》](http://share.weiyun.com/5b07d161d682533442489a3d6fbbffd9)系统学习如何写Makefile文件的。很多时候，有些写Makefile的命令或变量，我也还需要从这本书中去查。现在我觉得，这本书是Makefile编写的工具书，我今天写这个博客，当然不是指望，自己能比这本书写的更好，如果你要系统的学习Makefile的编写，如果让我推荐书籍的话，我还是推荐这本书。我今天写博客，是为那些，打算做Linux下C语言开发，打算写用Makefile做自动化生成工具的的人，一个快速的入门，同时也说一下自己在使用make的时候遇到的一些坑。

现在自动化构建工具，已经有很多了，有的语言还不止一个，比如Java，最初的时候有ant，后来又有什么maven，现在安卓用的又是另外一个，各自有自己的优缺点，各自也有自己的用武之地。不同语言的IDE（集成开发环境）其实都是在为一个特定的语言，维护一个自动化的构建工具。我见过不少的人，开发程序，十分的依赖IDE。使用IDE，可以提高开发的速度，可以提高代码的规范程度，这些都是使用IDE的好处，对初学者来说，其实我十分不建议使用IDE来作为开发的工具，因为IDE做的太多，初学者就不知道中间发生的过程了。比如C语言中，我想如果你没有自己动手一步一步的把源码编译一遍，实际上是不理解，源码到可执行程序的编译过程是怎么样的。如果不自己写一个Makefile，就不会知道IDE是如何做到自动化构建的。

以上算是开场白。下面正式开始今天的介绍。

Makefile文件不好写，不仅仅是因为我们对make程序的特性了解的不够清楚，而是因为写好Makefile，需要的背景知识很多，很多时候，写不好Makefile未必是因为对Makefile的规则卡住的，更多的时候，是被那些我们使用Makefile的背景知识给卡住的。比如，Makefile中的命令，很多时候就是Shell中的命令，如果对Shell不够熟悉那当然是不能写出如自己希望那样工作的Makefile的。Makefile，大部分是为C或C++项目写的，编译器使用的是GCC或者是其他的程序，有时候我们预期的效果是编译器的特点参数才能产生的，如果不了解编译器的这些特效，当然也没有办法写出如自己预期工作的Makefile。

今天是这个系列的第一篇，讲一些最基础的东西。

首先的观念是，Makefile其实是一个解释性的语言，make程序是这个语言的解释器。不仅可以用Makefile来做C/C++的自动化构建程序，其实，只要你的外围的程序写的好，你可以用Makefile做很多事情。比如，为一个道菜做一个指导程序。

说Makefile是一个编程语言，可能会吓退很多初学者，"本来我是为了减少手动编译的麻烦才学习Makefile的，现在好了，有得学习一门新的语言，这不自己给自己找不自在吗？"其实不用有这样的担心，Makefile这个语言，和C语言，C++以及Java，Javascipt等等语言不一样，那些语言叫做通用目的编程语言，而Makefile相反，他是特定领域语言[DSL](https://en.wikipedia.org/wiki/Domain-specific_language "Domain Speciac Language")的一种。Makefile是特意为描述完成一个目标，需要的步骤而设计的语言。这个语言也只局限于这个目标，所以，这个语言设计的不复杂，学习的难度和C、C++等通用编程语言是没法比的。当时用这个语言来描述，完成一个目标的步骤，也特别的容易和清楚。

# Makefile中变量的定义#
好了，现在我们认定makefile是一个编程语言了，那么我们看看这个语言有哪些特性。
作为一个语言，首先有的应该就是变量了，Makefile中是支持变量的。Makefile中变量的用法和Shell中有几分像，但是又不全部一样。今天我们就只讲Makefile中的变量，其他的问题，以后再说。

在Makefile中，像在Shell中一样，直接对变量赋值就定义的一个变量。
例如下面这样：

```Makefile
SRC= test.c test.h
$(info SRC=$(SRC))  #or $(info SRC=${SRC})
```

第一行，定义了一个变量SRC，第二行，调用了一个Makefile的函数info展示类似这样的一个文本：`SRC= test.c test.h`。第二行中，`$(SRC)`被替换成了第一行中赋给`SRC`的值。

Makefile中定义变量的方式有好几种，引用变量的方式有三种方法，其中一种，和我们看到的第一个方法等效的写法，在第二行的注释中已经给出，也就是说`$`后用小括号或用大括号把变量名称括气来，都是对变量值的引用。我所以不推荐用大括号原因是，这种用法也是Shell中可行的变量引用的方法，如果这样用，就不容易区分是Makefile的代码还是Shell的代码，后面会看到，区分这两点有时候在写makefile的时候是很有必要的。除了这两种方法外，如果变量的名字只有一个字符，那么也可以不用括号，`$`后面直接跟一个字符的变量名。例如下面的这样：

```makefile
t: This is a test.
$(info t:$t)
test: hello
$(info test:$test)
```
注意第4行的内容，本来我们是期望输出"test:hello"的，但是实际上输出的是："This is a test.est"。这是因为第四行中`$test`等同于`$(t)est`,也就是说在变量t的后面在加上est。所以，一般来说，不是特殊的变量（Makefile的特殊变量是用一个字符表示的，后面讲到），自己一般不要使用一个字符的变量，自己对变量引用，如果不确定，就用括号括起来。

现在我们暂且把变量值的引用放下，来看看定义变量的几种不同的方法。

+ 使用`=`定义变量

    ```makefile
    SRC= test.c test.h
    ```
    这个方法定义的变量，无论变量之前有没有值，现在的值都是赋值之后的值。

+ 使用`?=`对变量赋值

    ```makefile
    SRC ?= test.c test.h
    ```
    这样定义的变量，只有当SRC在这之前是没有定义的时候才能被赋值为现在定义的值。

+ 使用`:=`对变量赋值

    ```makefile
    SRC := test.c test.h
    ```
    这种方式定义的变量在变量展开的时候和前面的两种方式不一样，下面看到第四种的方法的时候，举例说明。

+ 对变量追加内容`+=`

    ```makefile
    SCR1 = test.c test.h
    SCR2 := test.c test.h
    SCR2 += $(SCR2)
    $(info SCR2=$(SCR2)) #output "test.c test.h test.c test.h"
    SCR1 += SCR1 #error "unterminated variable reference."
    $(info SCR1=$(SCR1))
    ```

也就是说试用`:=`定义的变量，在展开(引用其值)的时候，立即展开，而其他形式定义的变量延迟展开（或者理解为循环展开）。`SCR1 += $(SCR1)`使得`SCR1`的值，不停的变换，因此就没有结束的时候，这也就是为什么最后的输出错误提示的意思。由`:=`定义的SCR2，解析`SCR2 += $(SCR2)`的时候，会立即把SCR2的当前的值展开，而不是等这个变量的值不变之后，在做最后的展开。所以，如果你定义的变量，在涉及到了循环引用（无论是现在这样的直接循环，又或者是多个变量之间相互的间接循环引用），为了避免引用不能结束的情况，就使用`:=`来定义变量。

# Makefile中依赖规则的表示#
上面我们讲了Makefile中的变量的定义，现在我们来看看Makefile中如何描述完成一个目标的过程。

Makefile中，这样来描述如何达到一个目标：

1. 目标是什么（目标名字），
2. 要达到这个目标需要准备些什么（目标的依赖），
3. 当准备的条件满足之后，需要执行什么样的动作，来完成目标。（生成目标的命令）

下面是一个简单的例子

```Makefile
helloworld:helloworld.c
    gcc -o helloworld helloworld.c
```

第一行，表示的是目标和它的依赖。第二行以Tab开头（因为编辑器的缘故，这里用的是空白，所以这里的代码事例，都不要直接复制黏贴使用），后面紧跟着是一个gcc命令，用来生成目标。以这样的形式，就完成了我们上面说的对一个目标如何完成进行简明的描述。

在上面的例子中，可以看到，在命令行中，常要使用目标和依赖条件的值，于是为了在命令行中方便的引用他们，Makefile定义了一些特殊的变量。

1. 表示目标的特殊变量`$@`
    在Makefile的命令行中使用`$@`，表示对目标的引用，因此上面的例子中，可以修改为如下的代码：

    ```makefile
    helloworld:helloworld.c
        gcc -o $@ helloworld.c
    ```
2. 表示全部依赖文件的变量`$^`
    如果在命令行，需要所有的依赖文件，那就可以用`$^`来表示，例如：

    ```Makefile
    test:main.c process.c
        gcc -o $@ $^
    ```
3. 表示依赖中的第一个`$<`
    有时候，在Makefile的命令行，不引用全部的依赖，而只用其中的第一个，这个时候就用到了`$<`，比如我们对一个C++的类代码编译的时候，目标文件的生成，即依赖代码的实现文件，又依赖头文件。但是编译的时候，我们不编译头文件，对头文件的编译会生成.gch的文件。如果我们不希望产生这些文件，而只想产生目标文件，那么我们就需要用`$<`这个变量。

    ```makefile
    all:Football.o Baskeatball.o
    Football.o:Football.cc Football.hh
        g++ -c -o $@ $^
    Baskeatball:Baskeatball.cc Baskeatball.hh
        g++ -c -o $@ $<
    ```
    在这里，第一个目标除了编译出Fooball.o之外，还多出了一个Fooball.hh.gch的东西， 有关文件的介绍，可以点击[这里](http://blog.csdn.net/cstn_kdlx/article/details/7254939 ".gch 文件"). 除了使用前面连接中说的G++参数来阻止 .gch文件的生产外，在编译的时候，不把头文件放在命令行中，如例子中对`Baskeatball.o`产生的命令那样，也可以不生成.gch文件。

    当然了，有人说，那在依赖中去掉头文件不就可以来吗？不把头文件放在依赖中，的确可以避免头文件被编译，但是因为内敛函数是定义在头文件中，如果你的头文件中这些函数发生的改变，你是期望目标文件从新编译的，但是如果在依赖中去掉了头文件，这种情况下，那么这个目标文件就不会被重新编译。我想正因为这样的原因，所以在Makefile中才有了这个看似鸡肋的`$<` 特殊变量。

# 命令行中的陷阱#

一个目标的可能需要多个命令才能完成，这个时候，就需要注意了，在Makefile中，命令行中，每个独立的命令行都是在一个单独的进程中执行的，要想多条命令在一个进程中执行，就需要把他们放在一行，如果一行放不下，那就需要在行末使用连行符号`\`。
例如：

```makefile
obj:
    if [! -e obj] ;\
    then mkdir obj;\
    fi;
```

如果我们去掉上面例子中行末的`\`,因为每行都是在一个Shell中执行的，这样每行都不是一个合法的Shell命令，所以就不能按照预期的那样工作。

我们在Makefile的命令行中可是使用Shell的所有的语法，但是需要注意，我们是在Makefile中，如果你的shell命令，需要引用变量，那么就需要使用`$$`来表示你的确表示`$`符号本身，而不是想引用Makfile中的变量的值。下面是一个对当前目录下的几个子目录都执行make命令的一个makefile示例：

```Makefile
DIRS= A B C D
build:
    for dir in $(DIRS);\
    do (cd $$dir && make)&;\
    done
```
注意第4行中的`$$dir`，首先是make把他解释为`$dir`，然后传递而shell。在Shell程序中，再把它计算为dir变量的值。 如果我们在第4行中，去掉一个`$`,那么make程序，首先要找dir的值，结果发现我们没有定义这个变量，所以传递给shell的就是一个空值。那么`cd`命令就会出错。
