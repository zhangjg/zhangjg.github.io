---
title : 安卓学习笔记--基础
layout: default
tags  : [读书,编程]

---


# Activities,Intents,Tasks #
Active 是用户界面的一个单元，一般来说就是Android设备的整个的屏幕。如果需要交互的安卓程序的话，你需要从一个Activity类的子类开始写起。Activitie类为安卓程序，提过了UI主件的可重用的，交互可变的部分。  

Intent类是安卓的通信单元。一个Intent表示了一个诸如一个Active要求另一个Active执行这样功能的抽象描述。

在安卓程序中每个Active之间基本上是分开的。实现一个Active的代码，不会在实现另一个Active的代码中直接调用。安卓框架的其他元属，例如已经提到的Intent，用来管理通讯的问题。因此，不鼓励保持一个Activity对象的引用。安卓运行时，创建和管理Active以及其他的应用程序主件。

用户接口不是基于函数调用来完成控制流的，而是应用程序描述一个表示他们想要执行的Intent,并要求系统找到一个匹配这个Intent的Active来执行实现控制流的转化的。
安卓程序可以通过Intent来跨越多个应用,实际上也是多个进程的Active连为一个Task（任务）。

# Serice #
安卓的Server（服务）类是为那些可以是活跃的，但是不可见的后台任务准备的。服务允许程序长时间的运行,来共享服务。


#Content Provider 内容提供者#
内容提供者主件很想RESTfull的web服务，通过一个URI来访问他们，通过一个内容提供者子类使用和RESTfullweb操作平行的操作，例如放置或获取数据，来进一步的操作。以下是内容提供者可以对数据作的操作：创建（插入），读取（查询），更新，删除：  

  1. insert 一个内容提供者对象的insert方法和REST 的POST操作类似，用来向数据库中插叙新的数据。
  2. query 一个内容提供者对象的query方法和REST 的GET操作类似。他返回一个特殊的叫做Cursor的集合对象，其中包含了记录的集合。
  3. update 一个内容提供者类的update操作类似于REST的 UPDATE操作。他使用更新的数据替代数据库中的数据。
  4. delete 一个内容提供者类的delete操作类似于REST的DELETE操作。它从数据库中移除匹配的记录。

内容提供者主件是安卓内容模型的核心，通过提过一个内容提供者，你的应用程序可以和其他的应用程序分享数据，也可以管理这个应用程序的数据模型。对应的类，ContentResolver（内容接收者），使安卓系统的其他主件可以发现内容提供者。
内容提供者的操作既是一个持久化机制,又是一个进程间交互的机制。除了允许进程间的交互调用，内容提供者允许开发者跨进程的共享整个的SQL数据库：不是共享一个对象，内容提供者共享整个的SQL表。

#BroadcastReceiver 广播接受器#
BroadcastReceiver类使安卓的高层使用Intent对象进行进程间通讯的另外一种变种机制。一个广播接收器接受一个Intent对象的行为，和一个Activity类似，但是广播接收器没有自己的用户界面。一个广播接收器的典型用法是:它接受一个报警，使得app在一个特定的时间变成活跃的。系统可以广播一个消息（intent）给多个接收者。

#静态的应用程序资源和上下文#
像应用程序的名字，应用程序注册的事件，它需要的权限等这些东西,应用程序存储在一个叫做maiflfest的文件中。其他的诸如要显示的图片，或者是简单的字符串，或者是背景色，字体等等内容叫做应用程序的上下文，安卓程序通过Context类来访问这些信息。Activity和Service都是扩展自Context类，也就意味着，可以通过this指针来了访问Context对象的数据。

# 安卓程序是如何解决不同应用程序之间的数据安全问题的？ #
安卓系统巧妙的利用了Linux系统多用户功能。在应用程序安装的时候，安卓程序为每个应用程序的供应商创建一个用户，这样，不同的应用程序，就不能访问其他程序的数据、文件，除非这些应用程序是同一个供应商开发的。

# 一个活动的生命周期 #
一个活动的生命周期可以分成以下几个状态：  

 * 未启动状态
 * 启动
 * 运行
 * 暂停
 * 停止
 * 销毁

每个不同装状态之间的转化如下所示：

<pre>
     未启动
       |
       V
     启动 <-----
       |        |
       V        |
     运行<-- -  |
       |  ^  |  |
       V  |  |  |
   -- 暂停-  |  |
   |   |     |  |
   |   V     |  |
   |  停止----- |
   |   |        |
   |   V        |
   ->  销毁------
</pre>

在运行时发可能不得不销毁一个活动的时候，但是又希望在以后的时间可以重新启用这个活动的时候（从其他状态进入到暂停、停止状态的时候），运行时会调用onSaveInstanceState() 方法。当一个活动已经被销毁了，再次被重建的时候（从销毁状态，进入启动状态的时候），onRestoreInstanceState()方法将会被调用。一个新的Activity实例将会被创建，在上一个活动中，通过onSaveInstanceState()方法存储的数据，将会通过onRestoreInstanceState()方法被传递进来。


# 异步任务 #
安卓程序，当程序界面对用户的动作在一定的时间内没有响应的时候，系统会提示用户是不是强自的退出程序。为了避免这种情况的发生，在对界面作响应动作的代码中不能有长时间运行的代码执行，因为对界面响应的代码运行在UI线程中，如果这个线程被卡住，那么程序就美发响应用户的其他的操作了。所以对于需要很长时间才完成的动作，需要使用异步任务来完成。安卓框架为我们提供了抽象类AsyncTask。
AsyncTask是一个模板类，其中的模板参数有3个分别是：Params，Progress，Result。AsyncTask有3个抽象的方法需要子类实现，分别是：

```java
  class AsyncTask <Params,Progress,Result>
  {
          protected void onPreExecute();
          protected Result doInBackground(Params... args);
          protected void onProgressUpdate(Progress)
          protected void onPosExecute(Result result);
          ...
  }
```

一个异步任务执行的时候有4步：

  1. 在这个任务执行之前，onPreExecute()函数被UI线程调用。一般用来完成任务的设置，例如在界面上显示一个进度条。
  2. 当 onPreExecute()执行结束之后， doInBackground(Params...)，立即在后台线程中被调用了。这个步骤用来完成异步任务的主体部分。
  3. onProgressUpdate(Progress...) 这个函数,在publishProgress(Progress) 被调用（在 doInBackground()中被调用）之后,在UI线程中被执行。这个函数的调用时间是不确定的。一般用来更新后台任务的状态，例如更新进度条的进度。
  4. onPosExecute（Result） 这个函数在 doInBackground(Params...) 执行完成之后在UI线程中被调用。一般用来作任务的清理工作，例如进度条完成之后，界面切换到下一个动作的界面中去。

其中， doInBackground(Params...)的参数从execute(Params...)的参数中得来。 而 doInBackground()的返回结果是 onPosExecute()的输入参数。在 doInBackground（）中调用 publishProgress(Progress)的时候，他的参数传递给 onProgressUpdate() 。还需要注意的是，每个异步任务的实例，只能执行一次。一个AsyncTask实例，在第二次调用 execute的时候，就会抛出IllegalStateException。
要点总结如下：

  * 安卓UI是单线程的。要使用好UI，开发者需要满足队列模型。
  * 为了是UI线程的保持在活跃的状态，如果运行在其中的任务，需要很多毫秒才能结束，或者需要几百个指令才能完成，那么这个任务就不应该运行在UI线程中。
  * 并发编程非常的困难。很容易引入难以排查的错误。
  * AsyncTask 是运行异步小任务的一个很方便的工具。但必须牢记异步任务是运行在UI线程以外的其他线程中的。他不应该写UI线程中的数据，包括通过参数传递给他的参数。
  * 不可变对象是在并发的线程之间传递信息的有用的工具。


# Bundle 和 Activity的 恢复 #
在移动设备上开发程序，内存是十分宝贵的。在小的设备上其他的程序活跃的，可见的程序要占用空间，所以没有足够的空间留给依然运行，但是隐藏起来的程序。当隐藏的程序需要在再次变得可见的时候，界面对应的Activity就会被从新创建。Activity对象的onCreative(Bundle)方法在创建之后会立刻被调用。Bundle是一个和Map类似的集合对象，但是它的key只能是字符串，而vlalue的类型可以不同。通过Activity.onSaveInstanceState(Bundle,PersistableBundle)方法，可以把一个Activity恢复的时候需要使用的数据存储到一个Bundle对象中，这个对象在Activity创建的时候就会被传递给onCreative(Bundle)方法。从而可以在onCreative(Bundle)方法中恢复这个Activity之前运行的状态。
